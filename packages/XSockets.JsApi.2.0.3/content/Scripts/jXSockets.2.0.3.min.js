var Queue = function (a) { var b = this; this.settings = a; this.length = 0; this.items = []; this.timer = 0; b.items.push = function (c) { b.length++; if (b.length === 1) b.timer = setInterval(function () { var c = b.items.slice(0, 1); if (c.length === 1) { b.items.remove(c[0]); a.dequeued.call(this, c[0]) } }, a.interval); return Array.prototype.push.call(this, c) }; b.items.remove = function () { var c, d = arguments, e = d.length, f; while (e && this.length) { c = d[--e]; while ((f = this.indexOf(c)) != -1) { this.splice(f, 1) } } b.length--; if (b.length === 0) { a.clean.call(this); clearInterval(b.timer) } return this }; this.enqueue = function (a) { b.items.push({ k: b.length, v: a }) }; this.cleanUp = function () { clearInterval(b.timer); b.items = [] }; this.Empty = function () { b.items.forEach(function (c) { a.dequeued.call(this, c); b.items.remove(c) }, this); clearInterval(b.timer) } }; var Subscriptions = function () { var a = []; this.add = function (c, d, e) { c = c.toLowerCase(); var f = this.get(c); if (f === null) { var g = new b(c); g.addCallback(d, e); a.push(g); return 1 } f.addCallback(d, e); return f.Callbacks.length }; this.get = function (b) { b = b.toLowerCase(); for (var c = 0; c < a.length; c++) { if (a[c].Name === b) return a[c] } return null }; this.getAll = function () { return a }; this.remove = function (b, c) { b = b.toLowerCase(); for (var d = 0; d < a.length; d++) { if (a[d].Name === b) { if (c === undefined) { a.splice(d, 1) } else { a[d].Callbacks.splice(c - 1, 1); if (a[d].Callbacks.length === 0) a.splice(d, 1) } return true } } return false }; this.fire = function (b, c, d, e) { b = b.toLowerCase(); for (var f = 0; f < a.length; f++) { if (a[f].Name === b) { if (e === undefined) { a[f].fireCallbacks(c, d) } else { a[f].fireCallback(c, d, e) } } } }; var b = function (a) { this.Name = a; this.Callbacks = []; this.addCallback = function (a, b) { this.Callbacks.push(new c(a, b)) }; this.fireCallback = function (a, b, c) { this.Callbacks[c - 1].fn(a); if (typeof this.Callbacks[c - 1].state === "object") { if (typeof this.Callbacks[c - 1].state.options !== "undefined" && typeof this.Callbacks[c - 1].state.options.counter !== "undefined") { this.Callbacks[c - 1].state.options.counter.messages--; if (this.Callbacks[c - 1].state.options.counter.messages === 0) { if (typeof this.Callbacks[c - 1].state.options.counter.completed === "function") { this.Callbacks[c - 1].state.options.counter.completed() } } } } if (b && typeof b === "function") { b() } }; this.fireCallbacks = function (a, b) { for (var c = 0; c < this.Callbacks.length; c++) { this.fireCallback(a, b, c + 1) } } }; var c = function (a, b) { this.fn = a; this.state = b }; return this }(); (function () { "use strict"; var a = { Queue: true, Delay: 30, Events: { onError: "xsockets.onerror", open: "xsockets.xnode.open", close: "close", storage: { set: "xsockets.storage.set", get: "xsockets.storage.get", getAll: "xsockets.storage.getall", remove: "xsockets.storage.remove" }, serverstatus: { status: "xsockets.server.status" }, onBlob: "blob", connection: { getallclients: "xsockets.getallclients", onclientconnect: "xsockets.onclientconnect", onclientdisconnect: "xsockets.onclientdisconnect" } }, Utils: { extend: function (a, b) { if (arguments.length > 2) { for (var c = 1; c < arguments.length; c++) { extend(a, arguments[c]) } } else { for (var d in b) { a[d] = b[d] } } return a }, guid: function (a, b) { for (b = a = ""; a++ < 36; b += a * 51 & 52 ? (a ^ 15 ? 8 ^ Math.random() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-"); return b } }, WebSocket: function (b, c, d) { var e = null; var f = this; var g = XSockets.Utils.extend({ queue: a.Queue, apikey: null, parameters: {} }, d); this.handler = c; this.Channel = {}; if (g.queue) { var h = { dequeued: function (a) { k(a.v.event, a.v.json, a.v.callback) }, clean: function () { }, interval: a.Delay }; this.Queue = new Queue(h) } var i = { subscribe: "xsockets.subscribe", unsubscribe: "xsockets.unsubscribe", getSubscriptions: "xsockets.getsubscriptions", getAllSubscriptions: "xsockets.getallsubscriptions" }; var j = function (a) { var b = "?"; for (var c in a) { b += c + "=" + encodeURIComponent(a[c]) + "&" } b = b.slice(0, b.length - 1); return b }; this.close = function (a) { e.close(); if (typeof a === "function") a() }; this.bind = function (a, b, c, d) { var g = { options: c, ready: e.readyState }; if (g.ready === 1) { f.trigger(new XSockets.Message(i.subscribe, { Event: a })) } Subscriptions.add(a, b, g); if (d && typeof d === "function") { d() } }; this.unbind = function (a, b) { if (Subscriptions.remove(a)) { f.trigger(new XSockets.Message(i.unsubscribe, { Event: a })) } if (b && typeof b === "function") { b() } }; this.many = function (a, b, c, d) { f.bind(a, c, XSockets.Utils.extend({ counter: { messages: b, completed: function () { f.unbind(a) } } }, d)) }; this.one = function (a, b, c) { f.bind(a, b, XSockets.Utils.extend({ counter: { messages: 1, completed: function () { f.unbind(a) } } }, c)) }; this.trigger = function (a, b, c) { if (g.queue) { f.Queue.enqueue({ event: a, json: b, callback: c }) } else { k(a, b, c) } }; var k = function (a, b, c) { if (typeof a !== "object") { a = a.toLowerCase(); var d = XSockets.Message(a, b); n(d.toString()); if (c && typeof c === "function") { c() } } else { n(a.toString()); if (b && typeof b === "function") { b() } } }; this.send = function (a) { e.send(a) }; var l = function (a, b) { if (Subscriptions.get(a) === null) { return } if (typeof b === "string") { b = JSON.parse(b) } Subscriptions.fire(a, b, function () { }) }; var m = function (a) { var b = null; if (typeof a.data === "string") { var c = JSON.parse(a.data); b = c.event; l(b, c.data) } else { l(XSockets.Events.onBlob, a.data) } }; var n = function (a) { e.send(a) }; Array.prototype.removeItem = function (a) { for (var b = 0; b < this.length; b++) { if (escape(this[b]).match(escape(a.trim()))) { this.splice(b, 1); break } } return this }; if ("WebSocket" in window) { var o = window.localStorage.getItem("XSocketsClientStorageGuid" + c) !== null ? window.localStorage.getItem("XSocketsClientStorageGuid" + c) : null; if (g.apikey !== null) { g.parameters["apikey"] = g.apikey } if (o !== null) { g.parameters["XSocketsClientStorageGuid"] = o } b = b + j(g.parameters); e = new window.WebSocket(b, c) } if (e !== null) { f.bind(a.Events.open, function (a) { window.localStorage.setItem("XSocketsClientStorageGuid" + c, a.StorageGuid); var b = Subscriptions.getAll(); for (var d = 0; d < b.length; d++) { for (var e = 0; e < b[d].Callbacks.length; e++) { if (b[d].Callbacks[e].ready !== 1) { f.trigger(new XSockets.Message(i.subscribe, { Event: b[d].Name })) } } } }, { subscribe: false }); e.onclose = function (a) { f.Queue.cleanUp(); l("close", a) }; e.onopen = function (a) { l("open", a) }; e.onmessage = function (a) { m(a) } } return { close: f.close, bind: f.bind, unbind: f.unbind, one: f.one, many: f.many, on: f.bind, off: f.unbind, trigger: f.trigger, triggerBinary: f.send, send: f.send, Channel: f.Channel, subscribe: f.bind, publish: f.trigger } }, Channel: function () { var b = function (b, c, d) { var e = a.Utils.guid(); var f = b + "/" + e; var g = new XSockets.WebSocket(f, c, d); g.Channel = { Id: e, args: [f, c, d] }; return g }; var c = function (a) { return new XSockets.WebSocket(a.args[0], a.args[1], a.args[2]) }; return { Create: b, Connect: c } }(), Message: function (a, b) { var c = { event: a, data: JSON.stringify(b) }; this.JSON = function () { return c }(); this.toString = function () { return JSON.stringify(c) }; return this } }; if (!window.jXSockets) { window.jXSockets = a } if (!window.XSockets) { window.XSockets = a } })()